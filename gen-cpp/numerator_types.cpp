/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "numerator_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace numerator {

int _kOperationValues[] = {
  Operation::STR2ID,
  Operation::ID2STR
};
const char* _kOperationNames[] = {
  "STR2ID",
  "ID2STR"
};
const std::map<int, const char*> _Operation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kOperationValues, _kOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kErrorCodeValues[] = {
  ErrorCode::STR2ID_QUERIES_DISABLED
};
const char* _kErrorCodeNames[] = {
  "STR2ID_QUERIES_DISABLED"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Query::~Query() throw() {
}


void Query::__set_op(const Operation::type val) {
  this->op = val;
}

void Query::__set_strings(const std::vector<std::string> & val) {
  this->strings = val;
}

void Query::__set_ids(const std::vector<NumID> & val) {
  this->ids = val;
}

void Query::__set_failures(const std::vector<FailureIdx> & val) {
  this->failures = val;
}

const char* Query::ascii_fingerprint = "D478EE81C1C8AB0A3FEC2FF77EFAFD1F";
const uint8_t Query::binary_fingerprint[16] = {0xD4,0x78,0xEE,0x81,0xC1,0xC8,0xAB,0x0A,0x3F,0xEC,0x2F,0xF7,0x7E,0xFA,0xFD,0x1F};

uint32_t Query::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_op = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->op = (Operation::type)ecast0;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->strings.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->strings.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += iprot->readString(this->strings[_i5]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.strings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ids.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->ids.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readI64(this->ids[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->failures.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->failures.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readI32(this->failures[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.failures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Query::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Query");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strings", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strings.size()));
    std::vector<std::string> ::const_iterator _iter16;
    for (_iter16 = this->strings.begin(); _iter16 != this->strings.end(); ++_iter16)
    {
      xfer += oprot->writeString((*_iter16));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids.size()));
    std::vector<NumID> ::const_iterator _iter17;
    for (_iter17 = this->ids.begin(); _iter17 != this->ids.end(); ++_iter17)
    {
      xfer += oprot->writeI64((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failures", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->failures.size()));
    std::vector<FailureIdx> ::const_iterator _iter18;
    for (_iter18 = this->failures.begin(); _iter18 != this->failures.end(); ++_iter18)
    {
      xfer += oprot->writeI32((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Query &a, Query &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.strings, b.strings);
  swap(a.ids, b.ids);
  swap(a.failures, b.failures);
  swap(a.__isset, b.__isset);
}

Query::Query(const Query& other19) {
  op = other19.op;
  strings = other19.strings;
  ids = other19.ids;
  failures = other19.failures;
  __isset = other19.__isset;
}
Query& Query::operator=(const Query& other20) {
  op = other20.op;
  strings = other20.strings;
  ids = other20.ids;
  failures = other20.failures;
  __isset = other20.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Query& obj) {
  using apache::thrift::to_string;
  out << "Query(";
  out << "op=" << to_string(obj.op);
  out << ", " << "strings=" << to_string(obj.strings);
  out << ", " << "ids=" << to_string(obj.ids);
  out << ", " << "failures=" << to_string(obj.failures);
  out << ")";
  return out;
}


NumeratorException::~NumeratorException() throw() {
}


void NumeratorException::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void NumeratorException::__set_message(const std::string& val) {
  this->message = val;
}

const char* NumeratorException::ascii_fingerprint = "19B5240589E680301A7E32DF3971EFBE";
const uint8_t NumeratorException::binary_fingerprint[16] = {0x19,0xB5,0x24,0x05,0x89,0xE6,0x80,0x30,0x1A,0x7E,0x32,0xDF,0x39,0x71,0xEF,0xBE};

uint32_t NumeratorException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->code = (ErrorCode::type)ecast21;
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NumeratorException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("NumeratorException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(NumeratorException &a, NumeratorException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

NumeratorException::NumeratorException(const NumeratorException& other22) : TException() {
  code = other22.code;
  message = other22.message;
  __isset = other22.__isset;
}
NumeratorException& NumeratorException::operator=(const NumeratorException& other23) {
  code = other23.code;
  message = other23.message;
  __isset = other23.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const NumeratorException& obj) {
  using apache::thrift::to_string;
  out << "NumeratorException(";
  out << "code=" << to_string(obj.code);
  out << ", " << "message=" << to_string(obj.message);
  out << ")";
  return out;
}

} // namespace
